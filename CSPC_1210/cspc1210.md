MODULE 1 **********************************************
Computer programs are abundant in many people's lives today, carrying out applications on smartphones, tablets, and laptops, powering businesses like Amazon and Netflix, helping cars drive and planes fly, and much more.
A computer program consists of instructions executing one at a time. Basic instruction types are:
	• Input: A program receives data from a file, keyboard, touchscreen, network, etc.
	• Process: A program performs computations on that data, such as adding two values like x + y.
	• Output: A program puts that data somewhere, such as a file, screen, or network.
Programs use variables to refer to data, like x, y, and z below. The name is due to a variable's value "varying" as a program assigns a variable like x with new values.
Mathematical thinking became increasingly important throughout the industrial age, enabling people to successfully live and work. In the information age, many people believe computational thinking, or creating a sequence of instructions to solve a problem, will become increasingly important for work and everyday life. A sequence of instructions that solves a problem is called an algorithm.
The Python interpreter is a computer program that executes code written in the Python programming language. An interactive interpreter is a program that allows the user to execute one line of code at a time.
Code is a common word for the textual representation of a program (and hence programming is also called coding). A line is a row of text.
The interactive interpreter displays a prompt (">>>") that indicates the interpreter is ready to accept code. The user types a line of Python code and presses the enter key to execute the code. Initially, you may think of the interactive interpreter as a powerful calculator. The example program below calculates a salary based on a given hourly wage, the number of hours worked per week, and the number of weeks per year. The specifics of the code are described elsewhere in the chapter.
The Python interactive interpreter is useful for simple operations or programs consisting of only a few lines. However, entering code line-by-line into the interpreter quickly becomes unwieldy for any program spanning more than a few lines.
Instead, a programmer can write Python code in a file then provide that file to the interpreter. The interpreter begins by executing the first line of code at the top of the file and continues until the interpreter reaches the end.
	• A statement is a program instruction. A program mostly consists of a series of statements, and each statement usually appears on its own line.
	• An expression is a piece of code the interpreter evaluates to produce a value; for example, the code wage * hours * weeks is an expression that computes a number. The symbol * is used for multiplication. The names wage, hours, weeks, and salary are variables, which are named references to values stored by the interpreter.
	• A new variable is created by performing an assignment using the = symbol, such as salary = wage * hours * weeks, which creates a new variable called salary.
	• The print() function displays variables or expression values.
	• Characters such as "#" denote comments, which are optional but can be used to explain portions of code to a human reader.
	• Many code editors color certain words, as in the below program, to assist a human reader in understanding various words' roles.
Text is output from a Python program using the built-in function print( ). Ex: print("hello world!"). Text enclosed in quotes is known as a string. Text in strings may have letters, numbers, spaces, or symbols like @ or #. Ex: "hello123@zybooks.com", "Welcome!", and "2005" are strings.
Output can be moved to the next line using the newline character "\n". Ex: print("1\n2\n3") prints "1" on the first line, "2" on the second line, and "3" on the third line of output. An output newline is the equivalent of pressing the Enter key on a keyboard to get to the next line.
print() always outputs an invisible newline character at the end of the statement.
The value of a variable can be printed out via: print(variable_name) (without quotes around the variable name). A single output line may include multiple strings and variables separated by commas. A space character is automatically added between each.
Each use of print() outputs on a new line. However, sometimes a programmer may want to keep output on the same line. Adding end=" " inside of print() keeps the output of the next print on the same line, separated by a single space character. Ex: print("Hello", end=" "). Any character, or multiple characters, can be used instead of a space character.
An escape sequence is a string that has a special meaning, like the newline character "\n", that always starts with a backslash "\". Other escape sequences exist, such as "\t" to insert a tab, or "\\" to print an actual backslash character.
Any space, tab, or newline is called whitespace.
Many useful programs allow a user to enter values, such as typing a number, a name, etc.
The input() function is used to read input from a user. The statement best_friend = input() will read text entered by the user, and assign the result as a new string to the best_friend variable. The input() function causes the program to wait until the user has entered text and pushed the return key.
The string "123" (with quotes) is fundamentally different from the integer 123 (without quotes). The "123" string is a sequence of the characters "1", "2", and "3" arranged in a certain order, whereas 123 represents the integer value one-hundred twenty-three. Strings and integers are each an example of a type; a type determines how a value can behave. For example, integers can be divided by 2, but not strings (what sense would "Hello" / 2 make?). Types are discussed in detail later on.
Reading from input always results in a string type. However, often a programmer wants to read in an integer, and then use that number in a calculation. If a string contains only numbers, like "123", then the int() function can be used to convert that string to the integer 123.
As soon as a person begins trying to program, that person will make mistakes. One kind of mistake, a syntax error, violates a programming language's rules on how symbols can be combined to create a program. An example is putting multiple prints on the same line.
The interpreter will generate a message when encountering a syntax error. The error message will report the number of the offending line, in this case 7, allowing the programmer to fix the problem. Sometimes error messages can be confusing. Below, the message "invalid syntax" is not very precise but is the best information that the interpreter reports. With enough practice, a programmer becomes familiar with common errors and avoids them, preventing headaches later.
Note that syntax errors are found before the program is run by the interpreter. In the example below, none of the prints prior to the error is in the output.
The Python interpreter is able to detect syntax errors when the program is initially loaded, prior to actually executing any of the statements in the code. However, just because the program loads and executes does not mean the program is correct. The program may have another kind of error called a runtime error, in which a program's syntax is correct but the program attempts an impossible operation, such as dividing by zero or multiplying strings together (like "Hello" * "ABC").
A runtime error halts the execution of the program. Abrupt and unintended termination of a program is often called a crash of the program.
Consider the below program that begins executing, prints the salary, and then waits for the user to enter an integer value. The int() statement expects a number to be entered, but gets the text "Henry" instead.
Some errors may be subtle enough to silently misbehave, instead of causing a runtime error and a crash. An example might be if a programmer accidentally typed "2 * 4" rather than "2 * 40". The program would load correctly but would not behave as intended. Such an error is known as a logic error, because the program is logically flawed. A logic error is often called a bug.
Error type	Description
SyntaxError	The program contains invalid code that cannot be understood.
IndentationError	The lines of the program are not properly indented.
ValueError	An invalid value is used, which can occur if giving letters to int().
NameError	The program tries to use a variable that does not exist.
TypeError	An operation uses incorrect types, which can occur if adding an integer to a string

When developing software, a programmer must write, run, test, and debug code. Each of these tasks can be performed with different software. Ex: A text editor is needed to write code, and a Python interpreter is needed to run the code. An integrated development environment (IDE) is software that integrates a text editor and a Python interpreter, often with additional tools. Ex: Most IDEs include the ability to edit multiple files, a file manager for finding and organizing files, shortcut buttons, a debugger to help a programmer find bugs, and a console for entering commands and executing programs.
IDEs support multiple programming languages and are widely used in software development. IDLE is the official IDE included with most installations of the Python language. Other common IDEs for Python include Visual Studio Code, PyCharm, and XCode.
Most IDEs do not come pre-installed with an operating system and must be installed separately. Some IDEs are run locally on a computer, while others are cloud-based and are run using a web browser.
IDEs contain many features that can make programming more efficient and convenient. Common IDE features include the following.
	• Syntax highlighting uses different colors for keywords, variables, strings, and other code syntax elements. Syntax highlighting can help a programmer identify errors such as unclosed quotes and parentheses, missing colons, and misspellings.
	• Automatic delimiter completion adds a matching closing quotation mark, parenthesis, bracket, or brace when a corresponding opening symbol is typed, which can help errors be more easily identified.
	• Shortcut buttons allow various predefined operations to be performed with a single click. Ex: A common shortcut button allows a program to be run quickly without having to enter a command to pass the source file to the Python interpreter.
	• A file manager and multiple text editor tabs for separate files allow different programs, input files, and output files to be easily accessed and edited.
An IDE typically includes a console for user input and program output. A console (or terminal) is a text-based interface that allows a user to run programs, enter input, and view program output.
A console's command-line interface (CLI) is an interface that allows a user to enter commands to run programs and work with files. One advantage of a CLI is the ability to run a program with command-line arguments. A command-line argument is a value entered by a user after the program name when running a program from a command line. Ex: In the command ls -a, ls is the name of the program and -a is a command-line argument.

When people in the 1800s began using electricity for lights and machines, they created switches to turn objects on and off. A switch controls whether or not electricity flows through a wire. In the early 1900s, people created special switches that could be controlled electronically, rather than by a person moving the switch up or down. In an electronically controlled switch, a positive voltage at the control input allows electricity to flow, while a zero voltage prevents the flow. Such switches were useful for routing telephone calls. Engineers realized they could use electronically controlled switches to perform simple calculations. The engineers treated a positive voltage as a "1" and a zero voltage as a "0". 0s and 1s are known as bits (binary digits). They built connections of switches, or circuits, to perform calculations such as multiplying two numbers.
To support different calculations, circuits called processors were created to process (or execute) a list of desired calculations, each called an instruction. The instructions were specified by configuring external switches, as in the images below. Processors used to take up entire rooms. Today, these processors fit on a chip about the size of a postage stamp, containing millions or even billions of switches.
Instructions are stored in a memory. A memory is a circuit that can store 0s and 1s in each of a series of thousands of addressed locations, like a series of addressed mailboxes that each can store an envelope (the 0s and 1s). Instructions operate on data, which is also stored in memory locations as 0s and 1s.
For example, the instruction "Mul 97, #9, 98" would multiply the data in memory location 97 by 9, storing the result into memory location 98. So if the data in location 97 were 20, then the instruction would multiply 20 by 9, storing the result 180 into location 98. That instruction would actually be stored in memory as 0s and 1s, such as "011 1100001 001001 1100010", where 011 specifies a multiply instruction, and 1100001, 001001, and 1100010 represent 97, 9, and 98 (as described previously). The following animation illustrates the storage of instructions and data in memory for a program that computes F = (9*C)/5 + 32, where C is memory location 97 and F is memory location 99.
The programmer-created sequence of instructions is called a program, application, or just app.

When powered on, the processor starts by executing the instruction at location 0, then location 1, then location 2, etc. The above program performs the calculation over and over again. If location 97 is connected to external switches and location 99 to external lights, then a computer user (like the women in the above picture) could set the switches to represent a particular Celsius number, and the computer would automatically output the Fahrenheit number using the lights.
In the 1940s, programmers originally wrote each instruction using 0s and 1s, such as "001 1100001 001001 1100010". Instructions represented as 0s and 1s are known as machine instructions, and a sequence of machine instructions together form an executable program (or an executable). Because 0s and 1s are hard to comprehend, programmers soon created programs called assemblers to automatically translate instructions for humans, such as "Mul 97, #9, 98", known as assembly language instructions, into machine instructions. The assembler program thus helped programmers write more complex programs.

In the 1960s and 1970s, programmers created high-level languages to support programming using formulas or algorithms, so a programmer could write a formula such as F = (9 / 5) * C + 32. Early high-level languages included FORTRAN (for "Formula Translator") or ALGOL (for "Algorithmic Language"), which were more closely related to how humans thought than were machine or assembly instructions.

To support high-level languages, programmers created compilers, which are programs that automatically translate high-level language programs into executable programs.

The term computer has changed meaning over the years. The term originally referred to a person that performed computations by hand, akin to an accountant ("We need to hire a computer.") In the 1940s/1950s, the term began to refer to large machines like in the earlier photo. In the 1970s/1980s, the term expanded to also refer to smaller home/office computers known as personal computers or PCs ("personal" because the computer wasn't shared among multiple users like the large ones) and to portable/laptop computers. In the 2000s/2010s, the term may also cover other computing devices like pads, book readers, and smart phones. The term computer even refers to computing devices embedded inside other electronic devices such as medical equipment, automobiles, aircraft, consumer electronics, military systems, etc.

In the early days of computing, the physical equipment was prone to failures. As equipment became more stable and as programs became larger, the term software became popular to distinguish a computer's programs from the hardware on which they ran.

A computer typically consists of several components (see animation below):

Input/output devices: A screen (or monitor) displays items to a user. The above examples displayed textual items, but today's computers display graphical items, too. A keyboard allows a user to provide input to the computer, typically accompanied by a mouse for graphical displays. Keyboards and mice are increasingly being replaced by touchscreens. Other devices provide additional input and output means, such as microphones, speakers, printers, and USB interfaces. I/O devices are commonly called peripherals.

Storage: A solid-state drive (SSD) uses flash memory to store files and other data, such as program files, song/movie files, or office documents. SSDs are non-volatile, meaning they maintain their contents even when powered off. The SSD's flash memory stores 0s and 1s by tunneling electrons into special circuits on the memory's chip and extracting the bits with a "flash" of electricity that draws the electrons back out. SSDs replace hard disk drives used in older personal computers. Hard disk drives use spinning magnetic disks that are slower and consume more energy than SSDs.

Memory: RAM (random-access memory) temporarily holds data read from storage and is designed such that any address can be accessed much faster than SSD and disk. The "random access" term comes from being able to access any memory location quickly and in arbitrary order, without having to spin a disk to get a proper location under a head. RAM is costlier per bit than SSD and disk, due to RAM's higher speed. RAM chips typically appear on a printed-circuit board along with a processor chip. RAM is volatile, losing its contents when powered off. Memory size is typically listed in bits or in bytes, where a byte is 8 bits. Common sizes involve megabytes (million bytes), gigabytes (billion bytes), or terabytes (trillion bytes).

Processor: The processor runs the computer's programs, reading and executing instructions from memory, performing operations, and reading/writing data from/to memory. When powered on, the processor starts executing the program whose first instruction is (typically) at memory location 0. That program is commonly called the BIOS (basic input/output system), which sets up the computer's basic peripherals. The processor then begins executing a program called an operating system (OS). The operating system allows a user to run other programs and interfaces with the many other peripherals. Processors are also called CPUs (central processing units) or microprocessors (a term introduced when processors began fitting on a single chip, the "micro-" suggesting something small). Because speed is so important, a processor may contain a small amount of RAM on its own chip, called cache memory, accessible in one clock tick rather than several, for maintaining a copy of the most-used instructions/data.

Clock: A processor's instructions execute at a rate governed by the processor's clock, which ticks at a specific frequency. Processors have clocks that tick at rates such as 1 MHz (1 million ticks/second) for an inexpensive processor ($1) like those found in a microwave oven or washing machine, to 1 GHz (1 billion ticks/second) for costlier ($10-$100) processors like those found in mobile phones and desktop computers. Executing about 1 instruction per clock tick, processors thus execute millions or billions of instructions per second.

Computers typically run multiple programs simultaneously, such as a web browser, an office application, a photo editing program, etc. The operating system actually runs a little of program A, then a little of program B, etc., switching between programs thousands of times a second.
After computers were invented and occupied entire rooms, engineers created smaller switches called transistors, which in 1958 were integrated onto a single chip called an integrated circuit, or IC. Engineers continued to make transistors smaller, leading to Moore's Law: the doubling of IC capacity roughly every 18 months, which continued for several decades.

Note: Moore actually said every 2 years. And the actual trend has varied from 18 months. The key is that doubling occurred roughly every two years, causing much improvement over time. Wikipedia: Moore's law.

By 1971, Intel produced the first single-IC processor named the 4004, called a microprocessor (micro- suggesting something small), having 2,300 transistors. New, more powerful microprocessors appeared every few years, and by 2012, a single IC had several billion transistors containing multiple processors (each called a core).
A side note: A common way to make a PC faster is to add more RAM. A processor spends much of its time moving instructions/data between memory and storage, because not all of a program's instructions/data may fit in memory—akin to a chef who spends most of his/her time walking back and forth between a stove and pantry. Just as adding a larger table next to the stove allows more ingredients to be kept close by, a larger memory allows more instructions/data to be kept close to the processor. Moore's Law results in RAM being cheaper a few years after buying a PC, so adding RAM to a several-year-old PC can yield good speedups for little cost.
As computing evolved throughout the 1960s and '70s, programmers created scripting languages to execute programs without the need for compilation. A script is a program whose instructions are executed by another program called an interpreter. Interpreted execution is slower because it requires multiple interpreter instructions to execute one script instruction. But the advantages include avoiding the compilation step during programming and running the same script on different processors as long as each processor has an interpreter installed.

In the late 1980s, Guido van Rossum began creating a scripting language called Python and an accompanying interpreter. He derived Python from an existing language called ABC. The name Python came from the TV show Monty Python's Flying Circus, of which van Rossum was a fan. The goals for the language included simplicity and readability, while providing as much power and flexibility as other scripting languages such as Perl.

Python 1.0 was released in 1994 with support for some functional programming constructs derived from Lisp. Python 2.0 was released in 2000 and introduced automatic memory management (garbage collection) and features from Haskell and other languages. Python 2 officially reached "end-of-life" (no more fixes or support) in 2020 (Source: Python.org). Python 3.0 was released in 2008 to rectify various language design issues. Python 2.7 still remained popular for years, due largely to third-party libraries supporting only Python 2.7. Python 3.0 is not backward compatible, so Python 2.7 programs cannot run on Python 3.0 or later interpreters. However, Python 3.x versions have become widely used as new projects adopted the version.

Python is an open-source language, meaning the user community participates in defining the language and creating new interpreters. The language is also supported by a large community of programmers. A May 2025 survey that measures the popularity of various programming languages has found that Python (25.35%) is the most popular language.

For program output, whitespace is any blank space or newline. Most coding activities require a student program's output to match exactly the expected output, including whitespace. Students learning programming often complain:
Programming is all about precision. Programs must be created precisely to run correctly. Ex:

= and == have different meanings.
Using i where j was meant can yield a hard-to-find bug.
Not considering that n could be 0 in sum/n can cause a program to fail entirely in rare but not insignificant cases.
Counting from i being 0 to i < 10 vs. i <= 10 can mean the difference between correct output and a program outputting garbage.
In programming, every little detail counts. Programmers must pay extreme attention to detail.

Thus, another reason for caring about whitespace in program output is to help new programmers get into a "precision" mindset when programming. Paying careful attention to details like whitespace instructions, carefully examining feedback regarding whitespace differences, and then modifying a program to exactly match expected whitespace are exercises that strengthen attention to detail. Such attention can lead programmers to make fewer mistakes when creating programs, spend less time debugging, and instead create programs that work correctly.

MODULE 2**********************************************
In a program, a variable is a named item, such as x or num_people, that holds a value.

An assignment statement assigns a variable with a value, such as x = 5. That statement means x is assigned with 5, and x keeps that value during subsequent statements, until x is assigned again.

An assignment statement's left side must be a variable. The right side can be an expression, so a statement may be x = 5, y = x, or z = x + 2. The 5, x, and x + 2 are each an expression that evaluates to a value.

Because in programming = means assignment, a variable may appear on both the left and right as in x = x + 1. If x was originally 6, x is assigned with 6 + 1, or 7. The statement overwrites the original 6 in x.

Increasing a variable's value by 1, as in x = x + 1, is common and known as incrementing the variable.

Because in programming = means assignment, a variable may appear on both the left and right as in x = x + 1. If x was originally 6, x is assigned with 6 + 1, or 7. The statement overwrites the original 6 in x.

Increasing a variable's value by 1, as in x = x + 1, is common and known as incrementing the variable.

A programmer gives names to various items, such as variables (and also functions, described later). For example, x = 5 uses the name "x" to refer to the value 5. An identifier, also called a name, is a sequence of letters (a-z, A-Z), underscores (_), and digits (0–9), and must start with a letter or an underscore.

Python is case sensitive, meaning uppercase and lowercase letters differ. Ex: "Cat" and "cat" are different. The following are valid names: c, cat, Cat, n1m1, short1, and _hello. The following are invalid names: 42c (doesn't start with a letter or underscore), hi there (has a space), and cat$ (has a symbol other than a letter, digit, or underscore).

Names that start and end with double underscores (for example, __init__) are allowed but should be avoided because Python has special usages for double underscore names, explained elsewhere. A good variable name should describe the purpose of the variable, such as "temperature" or "age," rather than just "t" or "A".

Certain words like "and" or "True" cannot be used as names. Reserved words, or keywords, are words that are part of the language and cannot be used as a programmer-defined name. Many language editors will automatically color a program's reserved words. A list of reserved words appears at the end of this section.
A good practice when naming variables is to use all lowercase letters and to place underscores between words. This lowercase and underscore convention for naming variables originates from PEP 8, the Python style guide. PEP 8 (Python Enhancement Proposal) outlines the basics of how to write Python code neatly and consistently. Code is read more often than written, so having a consistent variable naming scheme helps to ensure that programmers can understand each other's code.

Programmers should create meaningful names that describe an item's purpose. If a variable will store a person's age, then a name like "age" is better than "a". A good practice when dealing with scientific or engineering names is to append the unit of measure. Ex: Instead of temperature, use temperature_celsius. Abbreviations should only be used if widely understandable, as in tv_model or ios_app. While meaningful names are important, very long variable names, such as "average_age_of_a_graduate_student", can make subsequent statements too long and hard to read. Programmers must find a balance between meaningful names and short names. Below are some examples of names that perhaps are less and more meaningful.

Table 2.2.2: Python 3 reserved keywords.
False      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield

The Python interpreter is a program that runs on a computer, just like an Internet browser or a text editor. Instead of displaying a web page or creating a document, the interpreter runs Python programs. An object represents a value and is automatically created by the interpreter when executing a line of code. For example, executing x = 4 creates a new object to represent the value 4. A programmer does not explicitly create objects; instead, the interpreter creates and manipulates objects as needed to run the Python code. Objects are used to represent everything in a Python program, including integers, strings, functions, lists, etc.

The animation below shows some objects being created while executing Python code statements in an interactive Python interpreter. The interpreter assigns an object to a location somewhere in memory automatically.

Above, the interpreter performs an addition of 2 + 2, resulting in the creation of a new object with a value of 4. Once 4 is printed, the object is no longer needed, so the object is automatically deleted from memory and thrown away. Deleting unused objects is an automatic process called garbage collection that frees memory space

Name binding
Name binding is the process of associating names with interpreter objects. An object can have more than one name bound to it, and every name is always bound to exactly one object. Name binding occurs whenever an assignment statement is executed, as demonstrated below.
Each Python object has three defining properties: value, type, and identity.

Value: A value such as "20", "abcdef", or "55".
Type: The type of the object, such as integer or string.
Identity: A unique identifier that describes the object.
The value of an object is the data associated with the object. For example, evaluating the expression 2 + 2 creates a new object whose value is 4. The value of an object is examined by printing that object.
The type of an object determines the object's supported behavior. For example, integers can be added and multiplied, while strings can be appended with additional text or concatenated together. An object's type never changes once created. The built-in function type() returns the type of an object.

The type of an object also determines the mutability of an object. Mutability indicates whether the object's value is allowed to be changed. Integers and strings are immutable; meaning integer and string values cannot be changed. Modifying the values with assignment statements results in new objects being created and the names bound to the new object.
The identity of an object is a unique numeric identifier, such as 1, 500, or 505534. Only one object at any time may have a particular identifier. The identity normally refers to the memory address where the object is stored. Python provides a built-in function id() that gives the value of an object's identity.
A floating-point number is a real number, like 98.6, 0.0001, or -666.667. The term "floating-point" refers to the decimal point appearing anywhere ("floating") in the number. Thus, float is a data type for floating-point numbers.

A floating-point literal is written with the fractional part even if that fraction is 0, as in 1.0, 0.0, or 99.0.

Scientific notation is useful for representing floating-point numbers that are much greater than or much less than 0, such as 
. A floating-point literal using scientific notation is written using an "e" preceding the power-of-10 exponent, as in 6.02e23 to represent 
. The "e" stands for exponent. Likewise, 0.001 is 
, so it can be written as 1.0e-3.

Float-type objects have a limited range of values that can be represented. For a standard 32-bit installation of Python, the maximum floating-point value is approximately 
, and the minimum positive floating-point value is approximately 
. Assigning a floating-point value outside of this range generates an OverflowError. Overflow occurs when a value is too large to be stored in the memory allocated by the interpreter. Ex: The program in the figure below tries to store the value 
, which causes an overflow error.

In general, floating-point types should be used to represent quantities that are measured, such as distances, temperatures, volumes, and weights. Integer types should be used to represent quantities that are counted, such as numbers of cars, students, cities, hours, and minutes.

Some floating-point numbers have many digits after the decimal point. Ex: Irrational numbers (Ex: 3.14159265359...) and repeating decimals (Ex: 4.33333333...) have an infinite number of digits after the decimal. By default, most programming languages output at least five digits after the decimal point. But for many simple programs, this level of detail is not necessary. A common approach is to output floating-point numbers with a specific number of digits after the decimal to reduce complexity or produce a certain numerical type (Ex: Representing currency with two digits after the decimal). The syntax for outputting the float my_float with two digits after the decimal point is print(f"{my_float:.2f}")

When outputting a certain number of digits after the decimal using print(), Python rounds the last output digit, but the floating-point value remains the same. Manipulating how numbers are output is discussed in detail elsewhere.

An expression is a combination of items, like variables, literals, operators, and parentheses, that evaluates to a value, like 2 * (x + 1). A common place where expressions are used is on the right side of an assignment statement, as in y = 2 * (x + 1).

A literal is a specific value in code like 2. An operator is a symbol that performs a built-in calculation, like +, which performs addition. Common programming operators are shown below.

Table 2.5.1: Arithmetic operators.
Arithmetic operator	Description
+	The addition operator is +, as in x + y.
-	The subtraction operator is -, as in x - y. Also, the - operator is for negation, as in -x + y, or x + -y.
*	The multiplication operator is *, as in x * y.
/	The division operator is /, as in x / y.
**	The exponent operator is **, as in x ** y (x to the power of y).

An expression evaluates to a value, which replaces the expression. Ex: If x is 5, then x + 1 evaluates to 6, and y = x + 1 assigns y with 6.

An expression is evaluated using the order of standard mathematics, and is also known in programming as precedence rules, listed below.

Table 2.5.2: Precedence rules for arithmetic operators.
Operator/Convention	Description	Explanation
( )	Items within parentheses are evaluated first.	In 2 * (x + 1), the x + 1 is evaluated first, with the result then multiplied by 2.
exponent **	** used for exponent is next.	In x**y * 3, x to the power of y is computed first, with the results then multiplied by 3.
unary -	- used for negation (unary minus) is next.	In 2 * -x, the -x is computed first, with the result then multiplied by 2.
* / %	Next to be evaluated are *, /, and %, having equal precedence.	(% is discussed elsewhere.)
+ -	Finally come + and - with equal precedence.	In y = 3 + 2 * x, the 2 * x is evaluated first, with the result then added to 3, because * has higher precedence than +. Spacing doesn't matter because y = 3+2 * x would still evaluate 2 * x first.
left-to-right	If more than one operator of equal precedence could be evaluated, evaluation occurs left to right. Note: The ** operator is evaluated from right-to-left.	In y = x * 2 / 3, the x * 2 is first evaluated, with the result then divided by 3.
A good practice is to include a single space around operators for readability, as in num_items + 2, rather than num_items+2. An exception is minus used as negative, as in: x_coordinate = -y_coordinate. Minus (-) used as negative is known as unary minus.

The division operator / performs division and returns a floating-point number. Ex:

20 / 10 is 2.0.
50 / 50 is 1.0.
5 / 10 is 0.5.
The floor division operator // can be used to round down the result of a floating-point division to the closest smaller whole number value. The resulting value is an integer type if both operands are integers; if either operand is a float, then a float is returned:

20 // 10 is 2.
50 // 50 is 1.
5 // 10 is 0. (5 = 10 * 0 + 5. So, the result is 0 and the remainder 5 is thrown away.)
5.0 // 2 is 2.0.
For division, the second operand of / or // must never be 0, because division by 0 is mathematically undefined.

The basic arithmetic operators include not just +, -, *, /, //, but also %. The modulo operator (%) evaluates the remainder of the division of two integer operands. Ex: 23 % 10 is 3.

Examples:

9 % 5 is 4. Reason: Since 9 = 5 * 1 + 4, the floor division 9 // 5 results in 1, and the remainder is 4.
70 % 7 is 0. Reason: 70 // 7 is 10 with remainder 0.
1 % 2 is 1. Reason: 1 // 2 is 0 with remainder 1.

The interactive Python interpreter allows a programmer to execute one line of code at a time. This method of programming is mostly used for very short programs or for practicing the language syntax. Instead, programmers typically write Python program code in a file called a script, and execute the code by passing the script as input to the Python interpreter.

Programmers often write code in more than just a single script file. Collections of logically related code can be stored in separate files and imported for use into a script that requires that code. A module is a file containing Python code that can be used by other modules or scripts. A module is made available for use via the import statement. Once a module is imported, any object defined in that module can be accessed using dot notation. Ex: A variable speed_of_light defined in universe.py is accessed via universe.speed_of_light.

Separating code into different modules makes management of larger programs simpler. For example, a simple Tetris-like game might have a module for input (buttons.py), a module for descriptions of each piece shape (pieces.py), a module for score management (score.py), etc.

The Python standard library, discussed elsewhere, is a collection of useful pre-installed modules. Modules also become more useful when dealing with topics such as functions and classes, where the logical boundaries of what code should be contained within a module is more obvious.

When a module is imported, all code in the module is immediately executed. Python programs often use the built-in special name __name__ to determine if the file was executed as a script by the programmer or imported by another module. If the value of __name__ is the string "__main__", then the file was executed as a script.

In the figure below, two files are provided: pet_names.py initializes some variables, and favorite_pet.py imports pet_names.py as a module and uses some of the variable values to write a message. Running pet_names.py as a script (python pet_names.py) causes the code within the if __name__ == "__main__" block to execute, which prints some pet statistics. When favorite_pet.py is run and pet_names.py is imported as a module, the pet statistics are not printed.

The if construct used in the program below is discussed elsewhere. For now, know that the code indented below the if __name__ == "__main__" block only executes when the file is passed to the interpreter directly.

While basic math operations like + or * are sufficient for some computations, programmers sometimes wish to perform more advanced math operations such as computing a square root. Python comes with a standard math module to support such advanced math operations. A module is Python code located in another file. The programmer can import the module for use in their own file, or in an interactive interpreter. The programmer first imports the module to the top of a file.

The math module provides a number of theoretic, trigonometric, and logarithmic operations that a programmer may use. A mathematical operation provided by the math module can be used as follows:

sqrt() is known as a function. A function is a list of statements that can be executed simply by referring to the function's name. The statements for sqrt() are within the math module itself and are not relevant to the programmer. The programmer provides a value to the function (like num above). The function executes its statements and returns the computed value. Thus, sqrt(num) above will evaluate to 7.0.

The process of invoking a function is referred to as a function call. The item passed to a function is referred to as an argument. Some functions have multiple arguments, such as the function pow(b, e), which returns be. The statement ten_generation_ancestors = 1024 * num_people could be replaced by ten_generation_ancestors = math.pow(2, 10) * num_people to be more clear.



Some programs need to use a random number. Ex: A game program may need to roll dice, or a website program may generate a random initial password.

The random module, in the Python Standard Library, provides functions that return random values. The random() function returns a random floating-point value each time the function is called, in the range 0 (inclusive) to 1 (exclusive).

The statement import random enables use of the random module.


Usually, a programmer wants a random integer restricted to a specific number of possible values. Python's randrange() function generates random integers within a specified range. A single positive integer argument can be passed to the randrange() function to return an integer between 0 (inclusive) and the specified value (exclusive). Ex: random.randrange(10) returns an integer with 10 possible values: 0, 1, 2, ..., 8, 9.
The technique above generates random integers with N possible values ranging from 0 to N-1. Ex: 6 values from 0 to 5. A programmer usually requires a range starting with a non-zero value x. Ex: 10 to 15, or -20 to 20. Two functions in the random module, randint() and randrange(), can produce random integers within a defined range.
The numbers generated by the random module are known as pseudo-random. "Pseudo" means "not actually, but having the appearance of." Internally, the random module has an equation to compute the next "random" number from the previous one, (invisibly) keeping track of the previous one. For the first call to any random function, no previous random number exists, so the function uses a built-in integer based on the current time, called a seed, to help generate a random number. Since the time is different for each program run, each program will get a unique sequence.

Reproducibility is important for testing some programs. Ex: Despite the appearance of randomness, classic arcade games like Pac-Man allow players to master the game by repeating winning behaviors. A programmer can specify the seed by calling the seed() function. Ex: random.seed(5). With a specific seed, each program run yields the same sequence of pseudo-random numbers

String variables represent text, such as the character "G" or the word "pineapple". Python uses Unicode to represent every possible character as a unique number, known as a code point. For example, the character "G" has the code point decimal value of 71. Below is a table with Unicode code points and the character represented by each code point. In total, there are over 1 million code points in the Unicode standard character set.

In addition to visible characters such as "a", "$", or "5", several special characters exist. A newline character, which indicates the end of a line of text, is encoded as 10. Since there is no visible character for a newline, the language uses the two-item sequence \n to represent a newline character. The \ is known as a backslash. Upon reaching a \, the interpreter recognizes that item as the start of a special character's two-item sequence and then looks at the next item to determine the special character. The two-item sequence is called an escape sequence.
Escape sequences can be ignored using a raw string. A raw string is created by adding an "r" before a string literal, as in r"this is a raw string\"", which would output as this is a raw string\".

Sometimes converting between a text character and the encoded value is useful. The built-in function ord() returns an encoded integer value for a string of length one. The built-in function chr() returns a string of one character for an encoded integer.


MODULE 3 **********************************************
By successfully completing the module, you should be able to:

Understand different data types in python and what kind of data they can store.
Understand how to represent different data types as strings or as part of strings. 
Understand how to use variables of different data types in python instructions.

A string is a sequence of characters that represents textual data like a person's name, a location, or a message to the user. A string can be created in various ways, such as from user input or from being defined in a program's source code. A string literal is a string defined in the source code of a program by surrounding the text value with single or double quotes, like 'MARY' or "MARY".

The string type is a special Python construct known as a sequence type: a type that orders a collection of objects into a sequence from first to last. A string's characters are ordered from the string's first letter to the last. A character's position in a string is called that character's index. The first character is at index 0, the second at index 1, and so on. Ex: The string "Trish" has character "T" at index 0, character "r" at index 1, etc.

A programmer can assign a string to a variable just as with other types like numbers. Ex: str1 = "Hello", or str1 = str2. The input() function can also be used to get strings from the user.

An empty string is a sequence type with 0 elements, created with two quotes. Ex: str1 = "".

A common operation is to find the length, or the number of characters, in a string. The len() built-in function can be used to find the length of a string (and any other sequence type like a list).

Programs commonly access an individual character of a string. As a sequence type, every character in a string has an index starting at 0 from the leftmost character. For example, the "A" in string "ABC" is at index 0, "B" is at index 1, and "C" is at index 2. A programmer can reference a character at a specific index by appending brackets [ ] containing the desired index after the name of a string variable:

Note that negative indices can be used to reference characters starting from the right-most character of the string, instead of the left-most. Ex: alphabet[-1] is "Z".

A program can add new characters to the end of a string in a process known as string concatenation. The expression "New" + "York" concatenates the strings New and York to create a new string NewYork. Most sequence types support concatenation. String concatenation does not contradict the immutability of strings, because the result of concatenation is a new string; the original strings are not altered. The "+" concatenation operator can be used multiple times in a single expression, and can be used with variables or string literals.

String concatenation can only include string objects. Attempting to concatenate a string and a number will produce a TypeError when executed, Ex: address = 332 + " Main Street". A programmer must convert the number to a string using the str() function first, Ex: address = str(332) + " Main Street".

Program output often includes expressions, such as variables or other calculations, as part of the output text. A formatted string literal, or f-string, allows a programmer to create a string with placeholder expressions that are evaluated as the program executes. An f-string starts with an f character before the starting quote and uses curly braces { } to denote the placeholder expressions. A placeholder expression is also called a replacement field, as its value replaces the expression in the final output.

An = sign is provided after the expression in a replacement field to print both the expression and its result, which is a useful debugging technique when dynamically generating lots of strings and output. Ex: f"{2*4=}" produces the string "2*4=8".

Additionally, double braces {{ and }} are used to place a curly brace into an f-string. Ex: f"{{Jeff Bezos}}: Amazon" produces the string "{Jeff Bezos}: Amazon".

A format specification inside a replacement field allows a value's formatting in the string to be customized. Ex: Using a format specification, a variable with the integer value 4 can be output as a floating-point number (4.0), with leading zeros (004), and aligned to the left or right, etc.

A format specification is introduced with a colon : in the replacement field. The colon separates the "what" on the left from the "how" on the right. The left "what" side is an expression to be evaluated, perhaps just a variable name or a value. The right "how" side is the format specification that determines how to show that value using special characters. Ex: {4:.2f} formats 4 as 4.00.

A presentation type is part of a format specification that determines how to represent a value in text form, such as an integer (4), a floating point (4.0), a fixed precision decimal (4.000), a percentage (4%), a binary (100), etc. A presentation type can be set in a replacement field by inserting a colon : and providing one of the presentation type characters described below.

More advanced format specifications, like fill and alignment, are provided in a later section.

A container is a construct used to group related values together and contains references to other objects instead of data. A list is a container created by surrounding a sequence of variables or literals with brackets [ ]. Ex: my_list = [10, "abc"] creates a new list variable my_list that contains the two items: 10 and "abc". A list item is called an element. A list is mutable, meaning that the elements in a list can be replaced, reordered, or removed.

A list is also a sequence type, meaning the contained elements are ordered by position in the list, known as the element's index, starting with 0. my_list = [ ] creates an empty list with no elements.

The animation below shows how a list is created and managed by the interpreter. A list is an object, and its value is a sequence of references to the list's elements.

Lists are useful for reducing the number of variables in a program. Instead of having a separate variable for the name of every student in a class, or for every word in an email, a single list can store an entire collection of related variables.

Individual list elements can be accessed using an indexing expression by using brackets as in my_list[i], where i is an integer. This allows a programmer to quickly find the i'th element in a list.

A list's index must be an integer. The index cannot be a floating-point type, even if the value is a whole number like 0.0 or 1.0. Using any type besides an integer will produce a runtime error, and the program will terminate.

Lists are mutable, meaning that a programmer can change a list's contents. An element can be updated with a new value by performing an assignment to a position in the list.

Since lists are mutable, a programmer can use methods to add and remove elements in the list. A method instructs an object to perform some action and is specified by providing the object name followed by a "." symbol and then the method name. The append() list method is used to add new elements to a list. Elements can be removed from a list using the pop() or remove() methods. Methods are covered in greater detail in another section.

Adding elements to a list:

list.append(value): Adds value to the end of list. Ex: my_list.append("abc")
Removing elements from a list:

list.pop(i): Removes the element at index i from list. Ex: my_list.pop(1)
list.remove(v): Removes the first element whose value matches v. Ex: my_list.remove("abc")

Methods like append(), pop(), and remove() are sequence-type methods. Sequence-type methods are functions built into the Python language definitions of sequence types like lists and strings. All sequence-type objects have associated methods that typically alter or return some information about the object.

Sequence-type functions are functions built into the Python language that take sequences like lists or strings as arguments and operate on the given sequences. They do not require an object or "." dot notation.Ex: len(my_list) retrieves the length of a sequence.

A subset of such functions and methods is provided below.

len(list)	Find the length of the list.
list1 + list2	Produce a new list by concatenating list2 to the end of list1.
min(list)	Find the element in the list with the smallest value. All elements must be of the same type.
max(list)	Find the element in the list with the largest value. All elements must be of the same type.
sum(list)	Find the sum of all elements of a list (numbers only).
list.index(val)	Find the index of the first element in the list whose value matches val.
list.count(val)	Count the number of occurrences of the value val in the list.

Note that lists can contain mixed types of objects. Ex: x = [1, 2.5, "abc"] creates a new list x that contains an integer, a floating-point number, and a string. Later material explores lists in detail, including how lists can even contain other lists as elements.

A tuple, usually pronounced "tuhple" or "toople," stores a collection of data, like a list, but is immutable – once created, the tuple's elements cannot be changed. A tuple is also a sequence type, supporting len(), indexing, and other sequence functions. A new tuple is generated by creating a list of comma-separated values, such as 5, 15, 20. Typically, tuples are surrounded with parentheses, as in (5, 15, 20). Note that printing a tuple always displays surrounding parentheses.

A tuple is not as common as a list in practical usage but can be useful when a programmer wants to ensure that values do not change. Tuples are typically used when element position, and not just the relative ordering of elements, is important. Ex: A tuple might store the latitude and longitude of a landmark because a programmer knows that the first element should be the latitude, the second element should be the longitude, and the landmark will never move from those coordinates.

A program commonly captures collections of data. Ex: a car is described using a series of variables describing the make, model, retail price, horsepower, and number of seats. A named tuple allows the programmer to define a new simple data type that consists of named attributes. A Car named tuple with fields like Car.price and Car.horsepower would more clearly represent a car object than a list with index positions correlating to some attributes.

The namedtuple container must be imported to create a new named tuple. Once the container is imported, the named tuple should be created like in the example below, where the name and attribute names of the named tuple are provided as arguments to the namedtuple constructor. Note that the fields to include in the named tuple are found in a list, but the fields may also be a single string with space- or comma-separated values.

A set is an unordered collection of unique elements. A set has the following properties:
Elements are unordered: Elements in the set do not have a position or index.
Elements are unique: No elements in the set share the same value.
A set can be created using the set() function, which accepts a sequence-type iterable object (list, tuple, string, etc.) whose elements are inserted into the set. A set literal can be written using curly braces { } with commas separating set elements. Note that an empty set can only be created using set().

Because the elements of a set are unordered and have no meaningful position in the collection, the index operator is not valid. Attempting to access the element of a set by position, for example nums1[2] to access the element at index 2, is invalid and will produce a runtime error.

A set is often used to reduce a list of items that potentially contains duplicates into a collection of unique values. Simply passing a list into set() will cause any duplicates to be omitted in the created set.

Sets are mutable – elements can be added or removed using set methods. The add() method places a new element into the set if the set does not contain an element with the provided value. The remove() and pop() methods remove an element from the set.

Additionally, sets support the len() function to return the number of elements in a set. To check if a specific value exists in a set, a membership test such as value in set (discussed in another section) can be used.

Adding elements to a set:

set.add(value): Add value into the set. Ex: my_set.add("abc")
Remove elements from a set:

set.remove(value): Remove the element with given value from the set. Raises KeyError if value is not found. Ex: my_set.remove("abc")
set.pop(): Remove a random element from the set. Ex: my_set.pop()

Operation	Description
len(set)	Find the length (number of elements) of the set.
set1.update(set2)	Adds the elements in set2 to set1.
set.add(value)	Adds value into the set.
set.remove(value)	Removes value from the set. Raises KeyError if value is not found.
set.pop()	Removes a random element from the set.
set.clear()	Clears all elements from the set.

Python set objects support typical set theory operations such as intersections and unions. Provided below is a brief overview of common set operations supported in Python:

set.intersection(set_a, set_b, set_c...)	Returns a new set containing only the elements in common between set and all provided sets.
set.union(set_a, set_b, set_c...)	Returns a new set containing all of the unique elements in all sets.
set.difference(set_a, set_b, set_c...)	Returns a set containing only the elements of set that are not found in any of the provided sets.
set_a.symmetric_difference(set_b)	Returns a set containing only elements that appear in exactly one of set_a or set_b

Consider a normal English language dictionary. A reader looks up the word "cat" and finds the definition, "A small, domesticated carnivore." The relationship between "cat" and its definition is associative, i.e., "cat" is associated with words describing "cat."

A dictionary is a Python container used to describe associative relationships. A dictionary is represented by the dict object type. A dictionary associates (or "maps") keys with values. A key is a term that can be located in a dictionary, such as the word "cat" in the English dictionary. A value describes some data associated with a key, such as a definition. A key can be any immutable type, such as a number, string, or tuple; a value can be any type.

A dict object is created using curly braces { } to surround the key:value pairs that comprise the dictionary contents. Ex: players = {"Lionel Messi": 10, "Cristiano Ronaldo": 7} creates a dictionary called players with two keys: "Lionel Messi" and "Cristiano Ronaldo", associated with the values 10 and 7 (their respective jersey numbers). An empty dictionary is created with the expression players = { }.

Dictionaries are typically used in place of lists when an associative relationship exists. Ex: If a program contains a collection of anonymous student test scores, those scores should be stored in a list. However, if each score is associated with a student name, a dictionary could be used to associate student names to their score. Other examples of associative relationships include last names and addresses, car models and price, or student ID number and university email address.

Though dictionaries maintain a left-to-right ordering, dictionary entries cannot be accessed by indexing. To access an entry, the key is specified in brackets [ ]. If no entry with a matching key exists in the dictionary, then a KeyError runtime error occurs and the program is terminated.
A dictionary is mutable, so entries can be added, modified, and deleted as necessary by a programmer. A new dictionary entry is added by using brackets to specify the key: prices["bananas"] = 1.49. A dictionary key is unique; attempting to create a new entry with a key that already exists in the dictionary replaces the existing entry. The del keyword is used to remove entries from a dictionary: del prices["papayas"] removes the entry whose key is "papaya". If the requested key to delete does not exist, then a KeyError occurs.

Adding new entries to a dictionary:

dict[key] = value: Adds the new pair key-value, if dict[key] does not already exist.
Example: prices["raisins"] = 2.13
Modifying existing entries in a dictionary:

dict[key] = value: Updates the existing entry dict[key], if dict[key] already exists.
Example: prices["raisins"] = 2.25
Removing entries from a dictionary:

del dict[key]: Deletes the entry dict[key].
Example: del prices["raisins"]

Numeric types int and float represent the most common types used to store data. All numeric types support the normal mathematical operations such as addition, subtraction, multiplication, and division, among others.

Sequence types string, list, and tuple are containers for collections of objects ordered by position in the sequence, where the first object has an index of 0 and subsequent elements have indices 1, 2, etc. A list and a tuple are very similar, except that a list is mutable and individual elements may be edited or removed. Conversely, a tuple is immutable and individual elements may not be edited or removed. Lists and tuples can contain any type, whereas a string contains only single characters. A programmer can apply sequence-type functions such as len() and element indexing using brackets [ ] to any sequence type.

The only mapping type in Python is the dict type. Like a sequence type, a dict serves as a container. However, each element of a dict is independent, having no special ordering or relation to other elements. A dictionary uses key-value pairs to associate a key with a value.

string	Sequence type: Used for text.
list	Sequence type: A mutable container with ordered elements.
tuple	Sequence type: An immutable container with ordered elements.
set	Set type: A mutable container with unordered and unique elements.
dictionary	Mapping type: A container with key-values associated elements.

New programmers often struggle with choosing a container type that best fits their needs, such as a list, tuple, or dict. In general, a programmer might use a list when data has an order, such as lines of text on a page. A programmer might use a tuple instead of a list if the contained data should not change. If order is not important, a programmer might use a dictionary to capture relationships between elements, such as student names and grades.

A calculation sometimes must mix integer and floating-point numbers. For example, given that about 50.4% of human births are males, then 0.504 * num_births calculates the number of expected males in num_births. If num_births is an integer type, then the expression combines a floating point and integer.

A type conversion is a conversion of one type to another, such as an integer to a float. An implicit conversion is a type conversion automatically made by the interpreter, usually between numeric types. For example, the result of an arithmetic operation like + or * will be a float only if either operand of the operation is a float.

1 + 2 returns an integer type.
1 + 2.0 returns a float type.
1.0 + 2.0 returns a float type.
integer-to-float conversion is straightforward: 25 becomes 25.0.

float-to-integer conversion just drops the fraction: 4.9 becomes 4.

Sometimes a programmer needs to explicitly convert an item's type. Conversion can be explicitly performed using the conversion functions below:
Function	Notes	Can convert:
int()	Creates integers	integer, float, strings w/integers only
float()	Creates floats	integer, float, strings w/integers or fractions
str()	Creates strings	Any

Converting a float to an integer will truncate the floating-point number's fraction. For example, the variable temperature might have a value of 18.75232, but can be converted to an integer expression int(temperature). The result would have the value 18 with the fractional part removed.

Conversion of types is very common. In fact, all user input obtained using input() is initially a string, and a programmer must explicitly convert the input to a numeric type.

Strings can also be converted to numeric types, if the strings follow the correct formatting, i.e. using only numbers and possibly a decimal point. For example, int("500") yields an integer with a value of 500, and float("1.75") yields the floating-point value 1.75.

Normally, a programmer thinks in terms of base 10 numbers. However, a computer must allocate some finite quantity of bits (e.g., 32 bits) for a variable, and that quantity of bits limits the range of numbers that the variable can represent. Python allocates additional memory to accommodate numbers of large sizes (past a typical 32 or 64 bit size), and a Python programmer need not think of such low-level details. However, binary base computation is an important part of computer science, so some background on how the quantity of bits influences a variable's number range is helpful.

Because each memory location is composed of bits (0s and 1s), a processor stores a number using base 2, known as a binary number.

For a number in the more familiar base 10, known as a decimal number, each digit must be 0-9, and each digit's place is weighed by increasing powers of 10.

In base 2, each digit must be 0-1 and each digit's place is weighted by increasing powers of 2.